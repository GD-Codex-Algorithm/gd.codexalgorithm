
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kinematic arriving movement</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <a href="../index.html" class="back-button">← Back to Home</a>
        <h1>Kinematic arriving movement</h1>
    </header>
    <main>
        <section>
            <h2>Kinematic arriving movement</h2>
            <h2> ROW 4</h2>
            <p>The kinematic arrive behaviour is designed to move a character towards a target position in a smooth and controlled manner, gradually slowing down as it approaches the target. This behaviour ensures that the character comes to a gentle stop at the target, rather than overshooting or abruptly stopping. The algorithm takes as input the character's current position and the target position, as well as additional parameters such as maximum speed, satisfaction radius, and time to target.

How it Works:
Direction Calculation: The algorithm first calculates the direction vector from the character to the target.
Within Radius Check: It then checks if the character is within the satisfaction radius of the target. If it is, the algorithm requests no further movement (returns null).
Velocity Calculation: If the character is outside the radius, the algorithm calculates the desired velocity to reach the target within a specified time (timeToTarget). This is done by dividing the direction vector by timeToTarget.
Speed Clipping: The calculated velocity is then clipped to ensure it does not exceed the maximum speed.
Orientation Update: The character's orientation is updated to face the direction of movement.
Return Steering Output: The resulting velocity and rotation (which is zero in this case) are returned as the steering output.</p>
            //<img src="nan" alt="Kinematic arriving movement">
            <pre>class KinematicArrive:
    character: Static
    target: Static

    maxSpeed: float

    # The satisfaction radius.
    radius: float

    # The time to target constant.
    timeToTarget: float = 0.25

    function getSteering() -> KinematicSteeringOutput:
        result = new KinematicSteeringOutput()

        # Get the direction to the target.
        result.velocity = target.position - character.position

        # Check if we’re within the radius.
        if result.velocity.length() < radius:
            # Request no steering.
            return null

        # We need to move to our target; we'd like to
        # get there in timeToTarget seconds.
        result.velocity /= timeToTarget

        # If this is too fast, clip it to the max speed.
        if result.velocity.length() > maxSpeed:
            result.velocity.normalize()
            result.velocity *= maxSpeed

        # Face in the direction we want to move.
        character.orientation = newOrientation(
            character.orientation,
            result.velocity
        )

        result.rotation = 0
        return result
</pre>
        </section>
        <section>
            <h3>variables</h3>
            <p>Symbolic/Classic (hard-coded logic based on understandable rules)</p>
            <p>Rule-based system</p>
            <p>AI that plays</p>
            <p>Non-player character NPC</p>
            <p>Movement</p>
            <p>Any</p>
            <p>Any</p>
            <p>Is run locally, Runs on PC, Runs on Playstation, Runs on Xbox, Runs on mobile, Runs on handheld devices</p>
            <p>6</p>
            <p>1</p>
        </section>
    </main>
</body>
<style>
/* Styles for the Back to Home button */
.back-button {
    display: inline-block;
    margin: 10px;
    padding: 10px 15px;
    font-size: 14px;
    color: white;
    background-color: #007BFF;
    text-decoration: none;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.back-button:hover {
    background-color: #0056b3;
}
</style>
</html>
